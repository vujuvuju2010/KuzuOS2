#include "filesystem.h"
#include "memory.h"
#include "process.h"
#include "vga.h"
#include "io.h"

// Disk I/O portları
#define DISK_DATA_PORT 0x1F0
#define DISK_ERROR_PORT 0x1F1
#define DISK_SECTOR_COUNT_PORT 0x1F2
#define DISK_LBA_LOW_PORT 0x1F3
#define DISK_LBA_MID_PORT 0x1F4
#define DISK_LBA_HIGH_PORT 0x1F5
#define DISK_DRIVE_PORT 0x1F6
#define DISK_COMMAND_PORT 0x1F7
#define DISK_STATUS_PORT 0x1F7

// Disk komutları
#define DISK_CMD_READ 0x20
#define DISK_CMD_WRITE 0x30

// File system buffer ve fs_header kaldırıldı

// RAM-backed virtual disk state
static uint8_t* ramdisk_buffer = 0;
static uint32_t ramdisk_total_sectors = 0;
static uint8_t ramdisk_enabled = 0;

static void* memset(void* dest, int c, uint32_t n) {
	uint8_t* d = (uint8_t*)dest;
	for (uint32_t i = 0; i < n; i++) d[i] = (uint8_t)c;
	return dest;
}

static void* memcpy(void* dest, const void* src, uint32_t n) {
	uint8_t* d = (uint8_t*)dest;
	const uint8_t* s = (const uint8_t*)src;
	for (uint32_t i = 0; i < n; i++) d[i] = s[i];
	return dest;
}

// Disk I/O fonksiyonları
int disk_wait() {
    uint8_t status;
    do {
        status = inb(0x1F7);
    } while ((status & 0x80) == 0x80);
}

int disk_read_sector(uint32_t lba, char* buffer) {
    if (ramdisk_enabled) {
        if (lba >= ramdisk_total_sectors) return -1;
        memcpy(buffer, ramdisk_buffer + (lba * 512), 512);
        return 0;
    }

    disk_wait();
    
    // LBA ayarla
    outb(0x1F2, 1); // 1 sector
    outb(0x1F3, (uint8_t)(lba & 0xFF));
    outb(0x1F4, (uint8_t)((lba >> 8) & 0xFF));
    outb(0x1F5, (uint8_t)((lba >> 16) & 0xFF));
    outb(0x1F6, (uint8_t)(((lba >> 24) & 0x0F) | 0xE0));
    
    // Read komutu gönder
    outb(0x1F7, 0x20);
    
    // Wait for data ready
    uint8_t status;
    do {
        status = inb(0x1F7);
        if (status & 0x01) { // Error bit
            return -1; // Error occurred
        }
    } while ((status & 0x08) == 0); // Wait for data ready
    
    // Data oku
    for (int i = 0; i < 256; i++) {
        uint16_t data = inw(0x1F0);
        buffer[i * 2] = data & 0xFF;
        buffer[i * 2 + 1] = (data >> 8) & 0xFF;
    }
    
    return 0; // Success
}

int disk_write_sector(uint32_t lba, char* buffer) {
    if (ramdisk_enabled) {
        if (lba >= ramdisk_total_sectors) return -1;
        memcpy(ramdisk_buffer + (lba * 512), buffer, 512);
        return 0;
    }

    disk_wait();
    
    // LBA ayarla
    outb(0x1F2, 1); // 1 sector
    outb(0x1F3, (uint8_t)(lba & 0xFF));
    outb(0x1F4, (uint8_t)((lba >> 8) & 0xFF));
    outb(0x1F5, (uint8_t)((lba >> 16) & 0xFF));
    outb(0x1F6, (uint8_t)(((lba >> 24) & 0x0F) | 0xE0));
    
    // Write komutu gönder
    outb(0x1F7, 0x30);
    
    // Data yaz
    for (int i = 0; i < 256; i++) {
        uint16_t data = buffer[i * 2] | (buffer[i * 2 + 1] << 8);
        outw(0x1F0, data);
    }
    
    // Wait for write completion and check for errors
    uint8_t status;
    do {
        status = inb(0x1F7);
        if (status & 0x01) { // Error bit
            return -1; // Error occurred
        }
    } while ((status & 0x80) == 0x80); // Wait for busy to clear
    
    return 0; // Success
}

// String fonksiyonları
static int strlen(const char* str) {
    int len = 0;
    while (str[len] != '\0') len++;
    return len;
}

static char* strchr(const char* str, char c) {
    while (*str != '\0') {
        if (*str == c) return (char*)str;
        str++;
    }
    return 0;
}

// Disk test function
int fs_disk_test() {
    char test_buffer[512];
    char test_data[512];
    for (int i = 0; i < 512; i++) test_data[i] = i & 0xFF;
    // Test write
    if (disk_write_sector(10, test_data) != 0) {
        print("Disk write test failed\n");
        return -1;
    }
    // Test read
    if (disk_read_sector(10, test_buffer) != 0) {
        print("Disk read test failed\n");
        return -1;
    }
    // Verify data
    for (int i = 0; i < 512; i++) {
        if (test_buffer[i] != test_data[i]) {
            print("Disk data verification failed\n");
            return -1;
        }
    }
    print("Disk I/O test passed\n");
    return 0;
}

#define FS_SECTOR_START 1000
#define FS_SECTOR_COUNT 8 // 8 sektör x 512 byte = 4096 byte

// Prototipler
static int fs_read_header(struct fs_header* header);
static int fs_write_header(const struct fs_header* header);

// FatFs global nesnesi

// RAMDISK API
void ramdisk_init(uint32_t total_sectors) {
    if (ramdisk_enabled) return;
    uint32_t bytes = total_sectors * 512;
    ramdisk_buffer = (uint8_t*)kmalloc(bytes);
    if (ramdisk_buffer) {
        ramdisk_total_sectors = total_sectors;
        memset(ramdisk_buffer, 0, bytes);
        ramdisk_enabled = 1;
        print("RAM disk enabled\n");
    } else {
        ramdisk_enabled = 0;
        print("RAM disk allocation failed\n");
    }
}

void ramdisk_preload_from_lba(uint32_t start_lba, uint32_t sector_count) {
    if (!ramdisk_enabled) return;
    char tmp[512];
    for (uint32_t i = 0; i < sector_count && (start_lba + i) < ramdisk_total_sectors; i++) {
        // Read from physical disk into RAM
        // Temporarily disable overlay to access hardware
        uint8_t prev = ramdisk_enabled;
        ramdisk_enabled = 0;
        int r = disk_read_sector(start_lba + i, tmp);
        ramdisk_enabled = prev;
        if (r != 0) break;
        // Copy into RAM buffer
        memcpy(ramdisk_buffer + ((start_lba + i) * 512), tmp, 512);
    }
}

    FRESULT fr = f_mount(&fs, "", 1);
    if (fr == FR_OK) print("FAT32 mounted!\n");
    else print("FAT32 mount failed!\n");
}

    DIR dir;
    FILINFO fno;
    if (f_opendir(&dir, path) == FR_OK) {
        while (f_readdir(&dir, &fno) == FR_OK && fno.fname[0]) {
            print(fno.fname);
            if (fno.fattrib & AM_DIR) print("/\n");
            else print("\n");
        }
        f_closedir(&dir);
    } else {
        print("ls failed\n");
    }
}

    FIL file;
    char buf[128];
    if (f_open(&file, filename, FA_READ) != FR_OK) {
        print("File not found\n");
        return -1;
    }
    UINT br;
    while (f_read(&file, buf, sizeof(buf), &br) == FR_OK && br > 0) {
        for (UINT i = 0; i < br; i++) putchar(buf[i]);
    }
    f_close(&file);
    print("\n");
    return 0;
}

    FRESULT fr = f_unlink(filename);
    if (fr == FR_OK) return 0;
    return -1;
}

    FRESULT fr = f_mkdir(dirname);
    if (fr == FR_OK) return 0;
    return -1;
}

    FIL file;
    FRESULT fr = f_open(&file, filename, FA_CREATE_NEW | FA_WRITE);
    if (fr == FR_OK) {
        f_close(&file);
        return 0;
    }
    return -1;
}

    FIL file;
    FRESULT fr = f_open(&file, filename, FA_WRITE | FA_CREATE_ALWAYS);
    if (fr != FR_OK) return -1;
    UINT bw;
    fr = f_write(&file, data, len, &bw);
    f_close(&file);
    return (fr == FR_OK && bw == len) ? 0 : -1;
}

void fs_init() {
    // Ramdisk: preload a window of the disk (e.g., first 64K sectors ~ 32MB)
    ramdisk_init(8192); // 131072 * 512 = 64MB

    // Preload disk into RAM (up to RAM disk size)
    ramdisk_preload_from_lba(0, ramdisk_total_sectors);

    // Disk I/O test yap
    if (fs_disk_test() != 0) {
        print("Disk I/O test failed, filesystem may not work properly\n");
    }

    // Dosya sistemini diskten oku
    struct fs_header header;
    if (fs_read_header(&header) != 0 || header.magic != FS_MAGIC) {
        // Diskte dosya sistemi yoksa veya bozuksa, yeni başlat
        for (int i = 0; i < sizeof(struct fs_header); i++)
            ((char*)&header)[i] = 0;
        header.magic = FS_MAGIC;
        header.num_files = 0;
        // Root dizini oluştur
        strcpy(header.files[0].name, "root");
        strcpy(header.files[0].path, "/");
        header.files[0].size = 0;
        header.files[0].offset = 0;
        header.files[0].used = 1;
        header.files[0].is_directory = 1;
        header.num_files = 1;
        fs_write_header(&header);
        print("Initialized new filesystem\n");
    } else {
        print("Existing filesystem loaded successfully\n");
    }
}


// Yardımcı fonksiyon: dosya sistemini diskten oku
static int fs_read_header(struct fs_header* header) {
    char buffer[4096];
    for (int i = 0; i < FS_SECTOR_COUNT; i++) {
        if (disk_read_sector(FS_SECTOR_START + i, buffer + i * 512) != 0)
            return -1;
    }
    // header'ı kopyala
    for (int i = 0; i < sizeof(struct fs_header); i++)
        ((char*)header)[i] = buffer[i];
    return 0;
}

// Yardımcı fonksiyon: dosya sistemini diske yaz
static int fs_write_header(const struct fs_header* header) {
    char buffer[4096] = {0};
    for (int i = 0; i < sizeof(struct fs_header); i++)
        buffer[i] = ((const char*)header)[i];
    for (int i = 0; i < FS_SECTOR_COUNT; i++) {
        if (disk_write_sector(FS_SECTOR_START + i, buffer + i * 512) != 0)
            return -1;
    }
    return 0;
}

int fs_create_directory(char* path) {
    struct fs_header header;
    if (fs_read_header(&header) != 0) return -1;
    if (header.num_files >= MAX_FILES) return -1;
    int slot = -1;
    for (int i = 0; i < MAX_FILES; i++) {
        if (!header.files[i].used) { slot = i; break; }
    }
    if (slot == -1) return -3;
    char* name = path;
    for (int i = 0; path[i] != '\0'; i++) if (path[i] == '/') name = &path[i + 1];
    if (name[0] == '\0') name = "root";
    strcpy(header.files[slot].name, name);
    strcpy(header.files[slot].path, path);
    header.files[slot].size = 0;
    header.files[slot].offset = 0;
    header.files[slot].used = 1;
    header.files[slot].is_directory = 1;
    header.num_files++;
    if (fs_write_header(&header) != 0) return -4;
    return 0;
}

int fs_create_file(char* path, char* data, uint32_t size) {
    struct fs_header header;
    if (fs_read_header(&header) != 0) return -1;
    if (header.num_files >= MAX_FILES) return -1;
    if (size > MAX_FILE_SIZE) return -2;
    int slot = -1;
    for (int i = 0; i < MAX_FILES; i++) {
        if (!header.files[i].used) { slot = i; break; }
    }
    if (slot == -1) return -3;
    char* name = path;
    for (int i = 0; path[i] != '\0'; i++) if (path[i] == '/') name = &path[i + 1];
    if (name[0] == '\0') name = "file";
    strcpy(header.files[slot].name, name);
    strcpy(header.files[slot].path, path);
    header.files[slot].size = size;
    header.files[slot].offset = sizeof(struct fs_header) + slot * MAX_FILE_SIZE;
    header.files[slot].used = 1;
    header.files[slot].is_directory = 0;
    // Dosya verisini yaz
    char buffer[4096] = {0};
    for (int i = 0; i < sizeof(struct fs_header); i++) buffer[i] = ((char*)&header)[i];
    for (uint32_t i = 0; i < size; i++) buffer[header.files[slot].offset + i] = data[i];
    for (int i = 0; i < FS_SECTOR_COUNT; i++) {
        if (disk_write_sector(FS_SECTOR_START + i, buffer + i * 512) != 0) return -4;
    }
    return 0;
}

int fs_read_file(char* path, char* buffer, uint32_t max_size) {
    char diskbuf[4096];
    for (int i = 0; i < FS_SECTOR_COUNT; i++) {
        if (disk_read_sector(FS_SECTOR_START + i, diskbuf + i * 512) != 0) return -1;
    }
    struct fs_header* header = (struct fs_header*)diskbuf;
    for (int i = 0; i < MAX_FILES; i++) {
        if (header->files[i].used && strcmp(header->files[i].path, path) == 0) {
            uint32_t size = header->files[i].size;
            if (size > max_size) size = max_size;
            char* file_data = diskbuf + header->files[i].offset;
            for (uint32_t j = 0; j < size; j++) buffer[j] = file_data[j];
            return size;
        }
    }
    return -1;
}

int fs_write_file(char* name, char* data, uint32_t size) {
    fs_delete_file(name, 0);
    return fs_create_file(name, data, size);
}

int fs_delete_file(const char* path, int recursive) {
    struct fs_header header;
    if (fs_read_header(&header) != 0) return -1;
    int found = 0;
    for (int i = 0; i < MAX_FILES; i++) {
        if (header.files[i].used && strcmp(header.files[i].path, path) == 0) {
            found = 1;
            // Eğer dizin ve recursive ise, altındaki her şeyi sil
            if (header.files[i].is_directory && recursive) {
                // Altındaki dosya ve dizinleri bul
                int pathlen = strlen(path);
                for (int j = 0; j < MAX_FILES; j++) {
                    if (header.files[j].used && strncmp(header.files[j].path, path, pathlen) == 0 && strcmp(header.files[j].path, path) != 0) {
                        // Alt eleman: recursive sil
                        fs_delete_file(header.files[j].path, 1);
                    }
                }
            } else if (header.files[i].is_directory && !recursive) {
                // Dizin ve recursive değilse, altı boş mu kontrol et
                int pathlen = strlen(path);
                for (int j = 0; j < MAX_FILES; j++) {
                    if (header.files[j].used && strncmp(header.files[j].path, path, pathlen) == 0 && strcmp(header.files[j].path, path) != 0) {
                        // Altında dosya/dizin var, silme
                        return -3;
                    }
                }
            }
            header.files[i].used = 0;
            header.num_files--;
            if (fs_write_header(&header) != 0) return -2;
            return 0;
        }
    }
    if (!found) return -1;
    return 0;
}

void fs_list_files(char* current_path) {
    char diskbuf[4096];
    for (int i = 0; i < FS_SECTOR_COUNT; i++) {
        disk_read_sector(FS_SECTOR_START + i, diskbuf + i * 512);
    }
    struct fs_header* header = (struct fs_header*)diskbuf;
    print("Files in "); print(current_path); print(":\n");
    int path_len = strlen(current_path);
    char norm_path[64];
    strcpy(norm_path, current_path);
    if (!(path_len == 1 && current_path[0] == '/') && current_path[path_len-1] != '/') {
        norm_path[path_len] = '/'; norm_path[path_len+1] = 0; path_len++;
    }
    for (int i = 0; i < MAX_FILES; i++) {
        if (!header->files[i].used) continue;
        char* fpath = header->files[i].path;
        if (strcmp(norm_path, "/") == 0) {
            if (strchr(fpath + 1, '/') == 0 || (strlen(fpath) > 1 && fpath[0] == '/' && strchr(fpath + 1, '/') == 0)) goto show_entry;
            continue;
        }
        if (strncmp(fpath, norm_path, path_len) == 0) {
            char* rest = fpath + path_len;
            char* next_slash = strchr(rest, '/');
            if (!next_slash || next_slash[1] == 0) goto show_entry;
        }
        continue;
show_entry:
        print("  ");
        if (header->files[i].is_directory) print("[DIR] ");
        else print("[FILE] ");
        print(header->files[i].name);
        if (!header->files[i].is_directory) {
            print(" (");
            char size_str[16];
            int size = header->files[i].size;
            int pos = 0;
            if (size == 0) size_str[pos++] = '0';
            else { while (size > 0) { size_str[pos++] = '0' + (size % 10); size /= 10; } }
            for (int j = pos - 1; j >= 0; j--) putchar(size_str[j]);
            print(" bytes)");
        }
        print("\n");
    }
}

int fs_file_exists(char* path) {
    struct fs_header header;
    if (fs_read_header(&header) != 0) return 0;
    for (int i = 0; i < MAX_FILES; i++) {
        if (header.files[i].used && strcmp(header.files[i].path, path) == 0) return 1;
    }
    return 0;
}

int fs_is_directory(char* path) {
    struct fs_header header;
    if (fs_read_header(&header) != 0) return 0;
    for (int i = 0; i < MAX_FILES; i++) {
        if (header.files[i].used && strcmp(header.files[i].path, path) == 0) return header.files[i].is_directory;
    }
    return 0;
}

